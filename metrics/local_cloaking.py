import pandas as pd
import numpy as np

from radius_knn import radius_knn


def local_cloaking(
    records_set_coordinates,
    avatars_set_coordinates,
    record_to_avatar_distances,
    subset_indices=None,
):
    """summary of global radius knn metric

    Arguments:
        records_set_coordinates {dataframe} -- a numpy or pandas dataframe containing coordinates of records
        avatars_set_coordinates {dataframe} -- a numpy or pandas dataframe containing coordinates of avatars
        record_to_avatar_distances {array} -- list of floats generated by the function record_to_avatar_distance

    Keyword Arguments:
        subset_indices {array} -- list of records indices that will be evaluated separately

    Returns:
        dict -- gathering useful informations
    """

    if records_set_coordinates.shape[0] != avatars_set_coordinates.shape[0]:
        raise ValueError(
            "dimension",
            "Records set and avatars set dataframes must have the same number of observations",
        )

    if records_set_coordinates.shape[0] != len(record_to_avatar_distances):
        raise ValueError(
            "distances",
            "The number of supplied distances is different from the number of observations in dataframes",
        )

    hit_counts = radius_knn(
        records_set_coordinates, avatars_set_coordinates, record_to_avatar_distances
    )

    no_hit = np.array([sum(t) == 0 for t in hit_counts])

    summary = {
        "empty_rate": np.mean(no_hit),
        "avatars_median": np.median([t[0] for t in hit_counts]),
        "records_median": np.median([t[1] for t in hit_counts]),
        "hit_counts": hit_counts,
    }

    if subset_indices is not None:
        return {
            "all": summary,
            "subset": {
                "empty_rate": np.mean(no_hit[subset_indices]),
                "avatars_median": np.median([t[0] for t in hit_counts[subset_indices]]),
                "records_median": np.median([t[1] for t in hit_counts[subset_indices]]),
            },
        }
    else:
        return summary
